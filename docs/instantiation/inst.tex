\documentclass[a4paper]{article}

\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{parcolumns}

\title{An instantiation algorithm for TLA+ expressions}

\newcommand{\assignment}[1]{\{#1\}}
\newcommand{\inst}[2]{#1 {\leftarrow} #2}
\newcommand{\einst}[3]{#1 \stackrel{#2}{\Leftarrow} #3}
\newcommand{\tlaplus}[0]{{TLA+}}
\newcommand{\tla}[1]{#1}
\newcommand{\sidebyside}[2]{
    \begin{minipage}{0.45\linewidth}
      #1
    \end{minipage}
    \space{10pt}
    \begin{minipage}{0.45\linewidth}
      #2
    \end{minipage}
}

\lstdefinelanguage{tlaplus}{
  morekeywords= { MODULE, LET, IN, VARIABLE, VARIABLES, CONSTANT, CONSTANTS,
    ASSUME, NEW, PROVE, THEOREM, LEMMA, ENABLED, ==, INSTANCE, BY, DEF },
  sensitive=true,
  morecomment=[l]{\*},
  morecomment=[s]{(*}{*)},
  morestring=[b]",
  literate={~} {$\sim$}{1},
  columns=fullflexible,
  basicstyle=\small
}

\lstset{language=tlaplus}

\begin{document}

\maketitle

\section{Overview}
\label{sec:overview}
\tlaplus{} has two kinds of substitution: instantiation of modules, which
 preserves validity, and beta-reduction of lambda-expressions, which does not
 necessarily preserve validity. Moreover, the two substitutions do not commute.
 For example, let us consider modules Foo and Bar:

\begin{parcolumns}{2}
\colchunk{
\begin{lstlisting}
---- MODULE Foo ----

VARIABLE x

E(u) == x' # u'
D(u) == ENABLED ( E(u) )

THEOREM T1 == ~ D(x)

====
\end{lstlisting}
}
\colchunk{
\begin{lstlisting}
---- MODULE Bar ----

VARIABLE y

I == INSTANCE Foo with x <- y


THEOREM T2 == D(y)

====
\end{lstlisting}
}
\end{parcolumns}

\vspace{2mm}
\noindent
It looks like \tla{I!T1} and \tla{T2} talk about the same formula \tla{D(y)},
 but this is not the case: the first can be read as \tla{I!(D(y))}\footnote{This
 is not valid \tlaplus{} syntax.} and the second as \tla{(I!D)(y)}. In other
 words, it makes a difference if we beta-reduce first or if we instantiate
 first. Reducing D(x) first leads to \tla{ENABLED (x' \# x')}, which -- following the
 renaming instuctions in ``Specifying Systems'' -- becomes \tla{ENABLED (\$x'
 \# \$x')} by the instantiation of \tla{x} with \tla{y}, where primed
 occurrences of \tla{\$x} are bound by their enclosing ENABLED and therefore
 untouched.

Instantiating first keeps the occurrence of the  variable \tla{u} intact,
 leading to \tla{I!D(u) == ENABLED ( u \# \$x') }. Unfolding the definitions and
 reducing the application \tla{I!D(y)} subsequently leads to
 \tla{ENABLED (y' \# \$x')}. Now it is clear that \tla{I!(D(y))} is
 unsatisfiable while \tla{(I!D)(y)} is satisfiable. Since \tlaplus{}
 contains set theory, finite domains -- and in particular, single element
 domains -- are excluded. Therefore \tla{(I!D)(y)} is a theorem in \tlaplus{}.

In the following, we will develop algorithms for both kinds of substitutions.
 Since inner substitutions have to be carried out before applying outer ones,
 special consideration will be taken with regard to partially unfolded
 definitions.

\section{New Attempt: Explicit subtitutions}

The original idea here is to represent both beta-reduction and instantiation
 explicitly in the term graph. Then the two formulas in the introduction
 could be written as D(u)\{u $\mapsto$ x\}[x $\mapsto$ y] and
 D(u)[x $\mapsto$ y]\{u $\mapsto$ x\}, where reduction is denoted by curly
 braces and instantiation is denoted by square braces. Actually, the SANY
 data-structures allow to write reduction as application to an abstraction:
 D(u)\{u $\mapsto$ x\} is then just \tla{(LAMBDA u: D(u))(x)}. Again, this
 is not legal \tlaplus{} but allowed by SANY.


\end{document}
