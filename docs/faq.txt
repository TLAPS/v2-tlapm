========================= Solved ==========================
Q: How do I build sany.jar:
A: in tlatoolbox call:
   mvn -P exporter -pl tlatools package

Q: Where can I get the toolbox after building?
A: After mvn package, the directory ./org.lamport.tla.toolbox.product.product/target/products/org.lamport.tla.toolbox.product.product/ contains folders os/toolkit/architecture. Copy the one you need to a directory.

Q: Are SANY UIDs unique?
A: In the SANY output yes, but there are eg. rewrites of ENABLED x which introduce a new bound variable.

Q: Which operators have implicit quantification? (i.e need special treatment during instantiation)
A: ENABLED, action composition (\cdot) and the -+-> operator. See TLA book chap 17.8, page 337.

Q: What is the difference between SubstInNode and APSubstInNode? (The comment in APSubstInNode.java says, that the former has an expr as body whereas the latter has a level node but expr are level nodes.)
A: Since Assume - Prove proofs were defined later, the original datastructure is SubstInNode, which only takes en expression. APSubstInNode support a wider range and can be generated by instantiating an Assume - Prove theorem.

Q: What happens to multiple (unnamed) INSTANCE statments of the same module?
A: If the module only contains declarations of variables, constants, etc it
   is accepted, but doesnt have an influence. As soon as definitions are added,
   the second INSTANCE is not acceptable without giving in a name via
   I == INSTANCE ... . See also TLA book section 17.5.5 (p. 331 in version
   02-08-08)

Q: Why does ENABLED rewriting need full definition expansion?
A: Take for example:

VARIABLE u,v
CONSTANT P(_), _ + _

D2(p(_),x) == p(x) => (p(x)')
APPLY(p(_),x) == p(x)

LEMMA FOLDED   == APPLY(LAMBDA x : ENABLED D2(P,x), u+v) BY DEF D2
LEMMA UNFOLDED == APPLY(LAMBDA x : ENABLED D2(P,x), u+v) BY DEF D2, APPLY

The only difference between FOLDED and UNFOLDED is the use of APPLY. Rewriting expanded
in the first case leads to:

APPLY(\E xp : (P(x) => P(xp)), u + v)

and in the second case to:

\E up,vp : (P(u + v) => P(up + vp))

Q: What is the meaning of ModuleInstanceKind?
A: Given a module instance I, with definitions I!A and I!B, we can write:
   THEOREM TRUE BY DEF I
   which needs to be expanded to
   THEOREM TRUE BY DEF I!A, I!B

At the moment, the xml format refers to the instance I just by its name (string).

Q: In v1 tlapm, what is the difference between an empty bullet list List(Refs []) and TRUE?
A: The difference between bullet lists and conjunctions is that the old code can refer directly to an index in the list. 

Q: What are different display modes of SANY elements?
A:
* Defined Operators: only the name, only the definiens, op(fp1,...,fpN) == definiens
* Theorem: only the name, only the body, name + body
* Assumption: only the name, only the body
* Module Instance: name == module with substitution, explicit instantiation node (unprintable in TLA)
* Instance steps:
* Label: name, ?
* Module: name, full

Q: For v1-tlapm under Windows, newer cygwin installations only provide cyggmp-4.dll, but Isabelle2014/PolyML depends on
   cyggmp-3.dll. How can this be circumvented?
A: Go to http://cs.nyu.edu/~exact/core/gmp/index.html and download gmp-dynamic-cygwin-4.1.tar.gz . The bin directory
   contains cyggmp-3.dll. It needs to be put into /usr/local/lib/tlaps/Isabelle2011-1/contrib/polyml-5.4.0/x86-cygwin
   in the distribution.

Q: How do temporal operators (\EE and \AA) work?
A: Disregarding stuttering steps, \sigma |= \EE x : F[x] is true if there exists
   a behaviour \tau where each state agrees on the evaluation of variables up to
   the evaluation of x (i.e. \sigma_1 =_x \tau_1, ... ). If F[x] is a state
   formula, it will still only evaluated in \tau_1.

========================== Unsolved ========================

Q: Why does Zenon export report a bug when called with a list of zero bullet points?
A: unknown


Q: Which TLA constructs are syntactic sugar?
A: incomplete list:
   1) records r.m translates to r["m"]
   2) f[x \in S] == e translates to f == CHOOSE f : f = [x \in S |-> e]
   3) things mentioned in chap 17.1.3 in the tla book
      3a) set union as successive union of singleton sets
      3b) multiple function assignments as composition of single assignment functions
      3c) module instantiations: M(x)!Op(x,y) is written as M!Op(x,y)
   4) things mentioned in chapter 16.2.3 in the tla book:
      4a) [A]_e == A \/ (e = e')
      4b) <A>_e == A /\ (e # e')
      4c) UNCHANGED e == (e = e')
   [...]

Q: Why does LS4 need True = x /\ ~x instead of TRUE?
A: It's Tomer's code, but probably there is an backend specific ast which has a different name for it.

Q: Which semantic checks are not done by sany?
A: Unknown, an incomplete list is:
   1) <1>1. QED BY <1>1 (self-reference in BY)
   2) <1>2. QED BY DEF <1>1 (def references proof step) -- fixed since 2015-02-04 
   [...]

Q: how to unify ASSUME NEW i ... with an eigenvariable in an assumption?
A: use the PICK operator?
