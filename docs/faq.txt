REMARK: These are personal notes specific to the implementation. A user faq will
 be introduced as soon as the code is runnable.

========================= Solved ==========================
Q: How do I build sany.jar:
A: in tlatoolbox call:
   mvn -P exporter -pl tlatools package

Q: How do I build the jar without the unit tests:
A: call:
   mvn -P exporter -Dmaven.test.skip=true  -pl tlatools package

Q: How do I strip signatures from sany.jar?
A:  Call:

  zip -d tlatools/target/org.lamport.tlatools-1.0.0-SNAPSHOT.jar \
  'META-INF/*.SF' 'META-INF/*.RSA' 'META-INF/*SF'

Q: Where can I get the toolbox after building?
A: After mvn package, the directory ./org.lamport.tla.toolbox.product.product/
    target/products/org.lamport.tla.toolbox.product.product/ contains folders
    os/toolkit/architecture. Copy the one you need to a directory.

Q: Are SANY UIDs unique?
A: In the SANY output yes, but there are eg. rewrites of ENABLED x which
   introduce a new bound variable.

Q: Which operators have implicit quantification? (i.e need special treatment
   during instantiation)
A: ENABLED, action composition (\cdot) and the -+-> operator. See TLA book
   chap 17.8, page 337.

Q: What is the difference between SubstInNode and APSubstInNode? (The comment in
   APSubstInNode.java says, that the former has an expr as body whereas the
   latter has a level node but expr are level nodes.)
A: Since Assume - Prove proofs were defined later, the original datastructure is
   SubstInNode, which only takes en expression. APSubstInNode should do the same
   for an ASSUME-PROVE and can be generated by instantiating an Assume - Prove
   theorem. The class only enforces a LevelNode, but it is always an
   AssumeProve.

   Please note that SubstInNode and APSubstInNode have to take care of the
   specifics of ENABLED (e.g. ENABLED 0 # 0 is not an instantiation of
   ENABLED x#x).

Q: What happens to multiple (unnamed) INSTANCE statments of the same module?
A: If the module only contains declarations of variables, constants, etc it
   is accepted, but doesnt have an influence. As soon as definitions are added,
   the second INSTANCE is not acceptable without giving it a name via
   I == INSTANCE ... . See also TLA book section 17.5.5 (p. 331 in version
   02-08-08)

Q: Why does ENABLED rewriting need full definition expansion?
A: Take for example:

VARIABLE u,v
CONSTANT P(_), _ + _

D2(p(_),x) == p(x) => (p(x)')
APPLY(p(_),x) == p(x)

LEMMA FOLDED   == APPLY(LAMBDA x : ENABLED D2(P,x), u+v) BY DEF D2
LEMMA UNFOLDED == APPLY(LAMBDA x : ENABLED D2(P,x), u+v) BY DEF D2, APPLY

The only difference between FOLDED and UNFOLDED is the use of APPLY. Rewriting
expanded in the first case leads to:

APPLY(\E xp : (P(x) => P(xp)), u + v)

and in the second case to:

\E up,vp : (P(u + v) => P(up + vp))

Q: What is the meaning of ModuleInstanceKind?
A: Given a module instance I, with definitions I!A and I!B, we can write:
   THEOREM TRUE BY DEF I
   which needs to be expanded to
   THEOREM TRUE BY DEF I!A, I!B

At the moment, the xml format refers to the instance I just by its name
 (string).

Q: In v1 tlapm, what is the difference between an empty bullet list
   List(Refs []) and TRUE?
A: The difference between bullet lists and conjunctions is that the old code can
   refer directly to an index in the list.

Q: What are different display modes of SANY elements?
A:
* Defined Operators: only the name, only the definiens,
  op(fp1,...,fpN) == definiens
* Theorem: only the name, only the body, name + body
* Assumption: only the name, only the body
* Module Instance: name == module with substitution, explicit instantiation node
  (unprintable in TLA)
* Instance steps:
* Label: name, ?
* Module: name, full

Q: For v1-tlapm under Windows, newer cygwin installations only provide
   cyggmp-4.dll, but Isabelle2014/PolyML depends on  cyggmp-3.dll. How can this
   be circumvented?
A: Go to http://cs.nyu.edu/~exact/core/gmp/index.html and download
   gmp-dynamic-cygwin-4.1.tar.gz . The bin directory
   contains cyggmp-3.dll. It needs to be put into /usr/local/lib/tlaps/
    Isabelle2011-1/contrib/polyml-5.4.0/x86-cygwin in the distribution.

Q: How do temporal operators (\EE and \AA) work?
A: Disregarding stuttering steps, \sigma |= \EE x : F[x] is true if there exists
   a behaviour \tau where each state agrees on the evaluation of variables up to
   the evaluation of x (i.e. \sigma_1 =_x \tau_1, ... ). If F[x] is a state
   formula, it will still only evaluated in \tau_1.

Q: Which kinds of proof steps are there?
A: This is a short summary of the TLA+2 guide. Assume G is the current goal.
   With proof:
   * Formula / Assume-Prove
   * CASE F : ASSUME F PROVE G
   * p1 SUFFICES F : suffices proves G and makes F the current goal
   * PICK :  prove \E x \in S : P(x) in subproof and
       make ASSUME NEW x \in S, NEW y \in T, P(x) PROVES G new goal
       (\E-introduction)
   * QED : prove current goal
   Without proof:
   * Definition
   * Instance
   * Use / Hide
   * HAVE F: replace goal H => I with ASSUME F PROVE I if H => F is a trivial
     consequence of H => I
   * TAKE : replace goal \A x : P(x) with P(x) (modulo alpha renaming)
      (\A-elimination)
   * WITNESS : replace goal \E x : P(x) with P(t) with t a term
     (\E-elimination)

Q: What is the formula of different proofs if i refer to them via BY?
A:
   * TAKE : TRUE
   * WITNESS : TRUE
   * PICK x \in S : F(x) : \E x \in S : F(x)

Q: Can I reference an assume prove within a formula?
A: Yes, but it needs instantiation. The fragment

THEOREM S == ASSUME TRUE PROVE 0=0
THEOREM T == S => 1=1

is not accepted by the parser, but

---- MODULE Foo ----
VARIABLE x
THEOREM S == ASSUME TRUE PROVE 0=0
====

I == INSTANCE Foo WITH x <- 2
THEOREM T == I!S => 1<-1

is accepted. It is yet undecided if the PM should accept this pattern.

Q: How can I see the input files, TLAPM v1 produces?
A: Use the flag: --debug tempfiles


Q: What is the semantics of: G BY A,B,C ?

This leads to four obligations:
1: A
2: ASSUME A PROVE B
3: ASSUME A,B PROVE C
4: ASSUME A,B,C PROVE G


========================== Unsolved ========================

Q: Why does Zenon export report a bug when called with a list of zero bullet
   points?
A: unknown


Q: Which TLA constructs are syntactic sugar?
A: incomplete list:
   1) records r.m translates to r["m"]
   2) f[x \in S] == e translates to f == CHOOSE f : f = [x \in S |-> e]
      In SANY this is an application to $RecursiveFcnSpec
   3) things mentioned in chap 17.1.3 in the tla book
      3a) set union as successive union of singleton sets
      3b) multiple function assignments as composition of single assignment
          functions
      3c) module instantiations: M(x)!Op(x,y) is written as M!Op(x,y)
   4) things mentioned in chapter 16.2.3 in the tla book:
      4a) [A]_e == A \/ (e = e')
      4b) <A>_e == A /\ (e # e')
      4c) UNCHANGED e == (e = e')
   [...]

Q: Why does LS4 need True = x /\ ~x instead of TRUE?
A: It's Tomer's code, but probably there is an backend specific ast which has a
   different name for it.

Q: Which semantic checks are not done by sany?
A: Unknown, an incomplete list is:
   1) <1>1. QED BY <1>1 (self-reference in BY)
   2) <1>2. QED BY DEF <1>1 (def references proof step) --fixed since 2015-02-04
   [...]

Q: how to unify ASSUME NEW i ... with an eigenvariable in an assumption?
A: use the PICK operator?

Q: What is the meaning of the different semantical entailments in TLA?
A: In the context of proofs, We have three entailments, |= , |[]= and ||= .
 The first one is the evaluation of a behaviour, the second one is true for boxed formulas
 only. And the third is a quantification on all behaviours. To prove a Lemma, you need the
 ||= operator. (missing: details and explanations)

